{%- macro fndef(fn) %}
{% if fn.static %}def_static{% else %}def{% endif %}
{% endmacro -%}

{%- macro genmethod(cls, fn) %}
  {% if fn.constructor %}
    .def(py::init<{{ fn.parameters | join(', ', attribute='x_type') }}>(){% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}, release_gil())
  {% else %}
    .{{ fndef(fn) }}("{{ fn.x_name }}",{{ ' ' }}
      {%- if 'overload' in fn.data or 'overloads' in fn.data -%}
        py::overload_cast<{{ fn.x_in_params | join(', ', attribute='x_type')}}>(
      {%- endif -%}
	     &{{ fn.namespace }}{{ cls.name }}::{{ fn.name }}
      {%- if 'overload' in fn.data or 'overloads' in fn.data -%}
        {% if fn.const %}, py::const_{% endif -%}
        )
      {%- endif -%}
		 {% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}
     {%- if 'no_release_gil' not in fn.data -%}
      , release_gil()
     {%- endif -%}
     {%- if fn.doc %},
       {% for dq in fn.doc_quoted %}
          {{ dq }}{% if loop.nextitem is defined %}{{ '\n' }}{% endif %}
       {%- endfor -%}
     {%- endif -%})
  {% endif %}
{% endmacro -%}

{%- macro unnamed_enum(x, enums) %}
{% for enum in enums %}
{% if 'name' not in enum %}
{% for val in enum['values'] %}
{{ x }}.attr("{{ val.name }}") = (int){{ enum.x_namespace }}{{ val.name }};
{% endfor %}
{% endif %}
{% endfor %}
{% endmacro -%}

/**
    This file is autogenerated
*/

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

{% for header in headers %}
#include <{{ header.rel_fname }}>
{% endfor %}

namespace py = pybind11;

{% for header in headers %}
{% for using  in header.using.values() %}
using {{ using.raw_type }};
{% endfor %}
{% endfor %}

// Use this to release the gil
typedef py::call_guard<py::gil_scoped_release> release_gil;

{% for inc in data.get("extra_includes", []) %}
#include "{{ inc }}"
{% endfor %}

void init_{{ mod_fn }}(py::module &m) {
{% for header in headers %}
{% for cls in header.classes if 'ignore' not in cls.data %}
  py::class_<{{ cls.namespace }}::{{ cls.name }}{% if 'cpp_inherits' in cls.data %}, {{ cls.data.cpp_inherits }}{% endif %}> {{ cls.name.lower() }}(m, "{{ cls.name }}");
  {{ cls.name.lower() }}
  {% for fn in cls.methods.public if 'ignore' not in fn.data and 'skip_pybind' not in fn.data and 'forward_declare' not in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.name.lower(), cls.enums.public) }}
{% endfor %}
{% endfor %}
{% for header in headers %}
{% for cls in header.classes if 'has_fwd_declare' in cls %}
  {{ cls.name.lower() }}
  {% for fn in cls.methods.public if 'forward_declare' in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.name.lower(), cls.enums.public) }}
{% endfor %}
{% endfor %}

  {% include "gen_enum_pybind11.cpp.j2" %}
}
