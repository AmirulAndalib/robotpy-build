{%- macro genbase(cls) -%}
{% if cls.x_inherits %}, {{ cls.x_inherits | join(', ', attribute='class')}}{% endif %}
{%- endmacro -%}

{%- macro fndef(fn) %}
{% if fn.static %}def_static{% else %}def{% endif %}
{% endmacro -%}

{%- macro fnptr(cls, fn) -%}
{% if fn.data.cpp_code %}
{{ fn.data.cpp_code }}
{% elif not fn.x_genlambda %}
&{% if cls %}{{ cls.x_qualname }}::{% else %}{{ fn.namespace }}{% endif %}{{ fn.name }}
{% else %}
[]({% if cls -%}
{{ cls.x_qualname }} * __that{% if fn.x_in_params %},{% endif %}
{% endif -%}{{ fn.x_in_params | join(', ', attribute='x_decl') }}) {
          {% for stmt in fn.x_lambda_pre %}
          {{ stmt }};
          {% endfor %}
          {{ fn.x_callstart }} {% if cls %}__that->{% endif %}{{ fn.name }}({{ fn.parameters | join(', ', attribute='x_callname') }} {{ fn.x_callend }});
          {% for stmt in fn.x_lambda_post %}
          {{ stmt }};
          {% endfor %}
          {{ fn.x_wrap_return }}
        }
{%- endif %}
{%- endmacro -%}

{%- macro genmethod(cls, fn) %}
  {% if fn.constructor %}
    .def(py::init<{{ fn.parameters | join(', ', attribute='x_type_full') }}>(){% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}, release_gil())
  {% else %}
    .{{ fndef(fn) }}("{{ fn.x_name }}",{{ ' ' }}
      {%- if fn.x_overloaded and not fn.data.cpp_code and not fn.x_genlambda -%}
        {#-
          py::overload_cast fails in some obscure cases, so we don't use it here
          https://github.com/pybind/pybind11/issues/1153
        -#}
        static_cast<{{ fn.rtnType }} ({% if cls and not fn.static %}{{ cls.name }}::{% endif %}*)({{
          fn.x_in_params | join(', ', attribute='x_type_full')
        }}){% if fn.const %} const{% endif %}>(
      {%- endif -%}
	     {{ fnptr(cls, fn) }}
      {%- if fn.x_overloaded -%}){%- endif -%}
		 {% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}
     {%- if not fn.data.no_release_gil -%}
      , release_gil()
     {%- endif -%}
     {{- fn.x_return_value_policy -}}
     {%- if fn.x_doc %},
       {% for dq in fn.x_doc_quoted %}
          {{ dq }}{% if loop.nextitem is defined %}{{ '\n' }}{% endif %}
       {%- endfor -%}
     {%- endif -%})
  {% endif %}
{% endmacro -%}

{%- macro genprop(qualname, prop) %}
    {% if prop.array_size is defined %}
    .def_property_readonly("{{ prop.x_name }}", []({{ qualname }}& inst) {
        return py::memoryview(py::buffer_info(
          &inst.{{ prop.name }}, sizeof({{ prop.type }}),
          py::format_descriptor<{{ prop.type }}>::format(),
          1, {{ "{" }}{{ prop.array_size }}{{ "}" }}, {sizeof({{ prop.type }})}
        ));
    })
    {% elif prop.array %}
    .def_property("{{ prop.x_name }}",
      [](const {{ qualname }}& inst) { return inst.{{ prop.name}}; },
      []({{ qualname }}& inst, const {{ prop.type }} v) {inst.{{ prop.name}} = v; })
    {% else %}
    .def_
      {%- if prop.constant or prop.constexpr or prop.data.readonly -%}
        readonly
      {%- else -%}
        readwrite
      {%- endif -%}
      {%- if prop.static %}_static{% endif -%}
      ("{{ prop.x_name }}", &{{ qualname }}::{{ prop.name}})
    {% endif %}
{% endmacro -%}

{%- macro unnamed_enum(x, enums) %}
{% for enum in enums %}
{% if 'name' not in enum %}
{% for val in enum['values'] %}
{{ x }}.attr("{{ val.name }}") = (int){{ enum.x_namespace }}{{ val.name }};
{% endfor %}
{% endif %}
{% endfor %}
{% endmacro -%}

// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>

{% for header in headers %}
#include <{{ header.rel_fname }}>
{% endfor %}

{% for inc in type_caster_includes %}
#include <{{ inc }}>
{% endfor %}

{% for header in headers %}
{% for using in header.using.values() %}
using {{ using.raw_type }};
{% endfor %}
{% endfor %}

{% for header in headers %}
{% for cls in header.classes
  if not cls.data.ignore and cls.x_has_trampoline %}
#include <rpygen/{{ cls.x_qualname_ }}.hpp>
{% endfor %}
{% endfor %}

{% for inc in data.extra_includes %}
#include <{{ inc }}>
{% endfor %}

void init_{{ mod_fn }}(py::module &m) {
{% for header in headers %}
{% for cls in header.classes if not cls.data.ignore %}

{% if cls.namespace %}
  using namespace {{ cls.namespace }};
{% endif %}
{% for typealias in cls.data.typealias %}
  using {{ typealias.split('::')[-1] }} = {{ typealias }};
{% endfor %}
{% for constant in cls.data.constants %}
  static constexpr auto {{ constant.split('::')[-1] }} = {{ constant }};
{% endfor %}

  py::class_<{{ cls.name }}
    {%- if cls.data.nodelete -%}
      , std::unique_ptr<{{ cls.name }}, py::nodelete>
    {%- elif cls.data.shared_ptr -%}
      , std::shared_ptr<{{ cls.name }}>
    {%- endif -%}
    {%- if cls.x_has_trampoline -%}
      , {{ cls.x_trampoline_name }}
    {%- endif %}{{ genbase(cls) }}> {{ cls.x_varname }}(m, "{{ cls.name }}");
  {{ cls.x_varname }}
  {# default constructor if not defined #}
  {% if not cls.x_has_constructor %}
    .def(py::init<>())
  {% endif %}
  {% for fn in cls.methods.public if not fn.data.ignore and 'forward_declare' not in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  {% for prop in cls.properties.public if not prop.data.ignore %}
  {{ genprop(cls.x_qualname, prop) }}
  {%- endfor %}
  {% for prop in cls.properties.protected if not prop.data.ignore %}
  {{ genprop(cls.x_trampoline_name, prop) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.x_varname, cls.enums.public) }}
{% endfor %}
{% endfor %}
{% for header in headers %}
{% for cls in header.classes if 'has_fwd_declare' in cls %}
  {{ cls.x_varname }}
  {% for fn in cls.methods.public if 'forward_declare' in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.x_varname, cls.enums.public) }}
{% endfor %}


{% if header.functions %}
{% for fn in header.functions if not fn.data.ignore %}
  {% if loop.first %}m{% endif %}
  {{ genmethod(None, fn) }}
{%- endfor %};
{% endif %}
{% endfor %}

  {% include "gen_enum_pybind11.cpp.j2" %}
}
