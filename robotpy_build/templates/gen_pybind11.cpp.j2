{%- macro fndef(fn) %}
{% if fn.static %}def_static{% else %}def{% endif %}
{% endmacro -%}

{%- macro fnptr(cls, fn) -%}
{% if fn.lambda is defined %}
{{ fn.lambda }}
{% elif not fn.x_out_params %}
&{% if cls %}{{ fn.namespace }}{{ cls.name }}::{% endif %}{{ fn.name }}
{% else %}
[]({{ fn.x_in_params | join(', ', attribute='x_decl') }}) {
          {{ fn.x_temprefs }}
          {{ fn.x_callstart }} {{ fn.name }}({{ fn.parameters | join(', ', attribute='x_callname') }} {{ fn.x_callend }});
          {{ fn.x_wrap_return }}
        }
{%- endif %}
{%- endmacro -%}

{%- macro genmethod(cls, fn) %}
  {% if fn.constructor %}
    .def(py::init<{{ fn.parameters | join(', ', attribute='x_type_full') }}>(){% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}, release_gil())
  {% else %}
    .{{ fndef(fn) }}("{{ fn.x_name }}",{{ ' ' }}
      {%- if 'overload' in fn.data or 'overloads' in fn.data -%}
        py::overload_cast<{{ fn.x_in_params | join(', ', attribute='x_type_full')}}>(
      {%- endif -%}
	     {{ fnptr(cls, fn) }}
      {%- if 'overload' in fn.data or 'overloads' in fn.data -%}
        {% if fn.const %}, py::const_{% endif -%}
        )
      {%- endif -%}
		 {% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}
     {%- if 'no_release_gil' not in fn.data -%}
      , release_gil()
     {%- endif -%}
     {%- if fn.doc %},
       {% for dq in fn.doc_quoted %}
          {{ dq }}{% if loop.nextitem is defined %}{{ '\n' }}{% endif %}
       {%- endfor -%}
     {%- endif -%})
  {% endif %}
{% endmacro -%}

{%- macro unnamed_enum(x, enums) %}
{% for enum in enums %}
{% if 'name' not in enum %}
{% for val in enum['values'] %}
{{ x }}.attr("{{ val.name }}") = (int){{ enum.x_namespace }}{{ val.name }};
{% endfor %}
{% endif %}
{% endfor %}
{% endmacro -%}

/**
    This file is autogenerated
*/

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

{% for header in headers %}
#include <{{ header.rel_fname }}>
{% endfor %}

namespace py = pybind11;

{% for header in headers %}
{% for using  in header.using.values() %}
using {{ using.raw_type }};
{% endfor %}
{% endfor %}

// Use this to release the gil
typedef py::call_guard<py::gil_scoped_release> release_gil;

{% for inc in data.get("extra_includes", []) %}
#include "{{ inc }}"
{% endfor %}

void init_{{ mod_fn }}(py::module &m) {
{% for header in headers %}
{% for cls in header.classes if 'ignore' not in cls.data %}
  py::class_<{{ cls.namespace }}::{{ cls.name }}{% if 'cpp_inherits' in cls.data %}, {{ cls.data.cpp_inherits }}{% endif %}> {{ cls.name.lower() }}(m, "{{ cls.name }}");
  {{ cls.name.lower() }}
  {% for fn in cls.methods.public if 'ignore' not in fn.data and 'skip_pybind' not in fn.data and 'forward_declare' not in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.name.lower(), cls.enums.public) }}
{% endfor %}
{% endfor %}
{% for header in headers %}
{% for cls in header.classes if 'has_fwd_declare' in cls %}
  {{ cls.name.lower() }}
  {% for fn in cls.methods.public if 'forward_declare' in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.name.lower(), cls.enums.public) }}
{% endfor %}


{% if header.functions %}
{% for fn in header.functions if 'ignore' not in fn.data and 'skip_pybind' not in fn.data %}
  {% if loop.first %}m{% endif %}
  {{ genmethod(None, fn) }}
{%- endfor %};
{% endif %}
{% endfor %}

  {% include "gen_enum_pybind11.cpp.j2" %}
}
