import os
from os.path import abspath, exists, dirname, join
from setuptools import find_packages, setup as _setup
import subprocess
import sys
import toml

from .command.build_dl import BuildDl
from .command.build_gen import BuildGen
from .command.build_ext import BuildExt

from .configs import RobotpyBuildConfig
from .pkgcfg_provider import PkgCfgProvider
from .platforms import get_platform
from .wrapper import Wrapper


class Setup:
    """
        Hacky wrapper around setuptools because it's easier than copy/pasting
        this stuff to a million setup.py files
    """

    def __init__(self):
        self.root = abspath(os.getcwd())
        self.wrappers = []

        with open(join(self.root, "pyproject.toml")) as fp:
            self.pyproject = toml.load(fp)

        self.project_dict = self.pyproject.get("tool", {}).get("robotpy-build", {})
        try:
            self.project = RobotpyBuildConfig(**self.project_dict)
        except Exception as e:
            raise ValueError(
                f"robotpy-build configuration in pyproject.toml is incorrect"
            ) from e

        self.platform = get_platform()

    @property
    def base_package(self):
        return self.project.base_package

    @property
    def git_dir(self):
        return join(self.root, ".git")

    @property
    def version_file(self):
        return join(self.root, self.base_package, "version.py")

    def prepare(self):

        self.setup_kwargs = self.project_dict.get("metadata", {})
        self.setup_kwargs["zip_safe"] = False
        self.setup_kwargs["include_package_data"] = True
        self.setup_kwargs["requires_python"] = ">=3.6"

        # TODO: autogen packages don't exist at sdist time
        #       ... but we want them to be added to the wheel
        self.setup_kwargs["packages"] = find_packages()

        self.setup_kwargs["long_description"] = self._generate_long_description()
        self.setup_kwargs["version"] = self._generate_version()

        self.pkgcfg = PkgCfgProvider()

        self._collect_wrappers()

        self.setup_kwargs["cmdclass"] = {
            "build_dl": BuildDl,
            "build_gen": BuildGen,
            "build_ext": BuildExt,
        }
        for cls in self.setup_kwargs["cmdclass"].values():
            cls.wrappers = self.wrappers

    def _generate_long_description(self):
        readme_rst = join(self.root, "README.rst")
        if exists(readme_rst):
            with open(readme_rst) as fp:
                return fp.read()

    def _generate_version(self):

        # TODO: this is really a custom egg_info implementation?

        version_file = self.version_file

        # Automatically generate a version.py based on the git version
        if exists(self.git_dir):
            p = subprocess.Popen(
                ["git", "describe", "--tags", "--long", "--dirty=-dirty"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            out, err = p.communicate()
            # Make sure the git version has at least one tag
            if err:
                print(
                    "Error: You need to create a tag for this repo to use the builder"
                )
                sys.exit(1)

            # Convert git version to PEP440 compliant version
            # - Older versions of pip choke on local identifiers, so we can't include the git commit
            v, commits, local = out.decode("utf-8").rstrip().split("-", 2)
            if commits != "0" or "-dirty" in local:
                v = "%s.post0.dev%s" % (v, commits)

            # Create the version.py file
            with open(version_file, "w") as fp:
                fp.write(f'# Autogenerated by setup.py\n__version__ = "{v}"\n')

        version = "master"
        if exists(version_file):
            env = {}
            with open(version_file, "r") as fp:
                exec(fp.read(), env)
            version = env.get("__version__", version)

        return version

    def _collect_wrappers(self):

        ext_modules = []

        for name, cfg in self.project.wrappers.items():
            w = Wrapper(name, cfg, self)
            self.wrappers.append(w)
            self.pkgcfg.add_pkg(w)

            if w.extension:
                ext_modules.append(w.extension)

        if ext_modules:
            self.setup_kwargs["ext_modules"] = ext_modules

    def run(self):
        # assemble all the pieces and make it work
        _setup(**self.setup_kwargs)


def setup():
    s = Setup()
    s.prepare()
    s.run()
